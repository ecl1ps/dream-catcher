import { SERVER_HOST, SERVER_PORT } from "@ecl1ps/dreamcatcher-shared";
import { app, screen, BrowserWindow, session } from "electron";
import { preselectDisplay } from "./preselectDisplay";
import { setupIpc } from "./setupIpc";
import { WebServer } from "./webServer";
import path from "path";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Vite
// plugin that tells the Electron app where to look for the Vite-bundled app code (depending on
// whether you're running in development or production).
declare const CONTROL_WINDOW_VITE_DEV_SERVER_URL: string;
declare const CONTROL_WINDOW_VITE_NAME: string;
declare const PLAYER_WINDOW_VITE_DEV_SERVER_URL: string;
declare const PLAYER_WINDOW_VITE_NAME: string;

const CONTROL_WINDOW_WIDTH = 385;
const CONTROL_WINDOW_HEIGHT = 650;

const debugControl = process.argv.includes("--debug-control");
const debugPlayer = process.argv.includes("--debug-player");
const enableWebServer = !process.argv.includes("--no-web-server");

let webServer: WebServer | null = null;

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

const getPlayerScreenBounds = (): Electron.Rectangle => {
  return preselectDisplay(screen.getAllDisplays()).bounds;
};

const createWindows = () => {
  const dimensions = getPlayerScreenBounds();
  const isMultiDisplay = screen.getAllDisplays().length > 1;

  const playerWindow = new BrowserWindow({
    ...dimensions,
    transparent: true,
    frame: false,
    fullscreen: true,
    alwaysOnTop: isMultiDisplay, // pin to top only on a different screen
    skipTaskbar: isMultiDisplay,
    hasShadow: true,
    title: "Dreamcatcher Player",
    webPreferences: {
      preload: path.join(__dirname, "player-preload.js"),
    },
  });

  playerWindow.hide();

  if (PLAYER_WINDOW_VITE_DEV_SERVER_URL) {
    playerWindow.loadURL(PLAYER_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    playerWindow.loadFile(
      path.join(__dirname, `../renderer/${PLAYER_WINDOW_VITE_NAME}/index.html`),
    );
  }

  const primaryDisplay = screen.getPrimaryDisplay();

  const controlWindow = new BrowserWindow({
    height: CONTROL_WINDOW_HEIGHT,
    width: CONTROL_WINDOW_WIDTH,
    x:
      primaryDisplay.bounds.x +
      primaryDisplay.workAreaSize.width -
      CONTROL_WINDOW_WIDTH -
      20,
    y:
      primaryDisplay.bounds.y +
      primaryDisplay.workAreaSize.height -
      CONTROL_WINDOW_HEIGHT -
      20,
    darkTheme: true,
    backgroundColor: "#222222",
    autoHideMenuBar: true,
    webPreferences: {
      preload: path.join(__dirname, "control-preload.js"),
    },
  });

  if (CONTROL_WINDOW_VITE_DEV_SERVER_URL) {
    controlWindow.loadURL(CONTROL_WINDOW_VITE_DEV_SERVER_URL);
  } else {
    controlWindow.loadFile(
      path.join(
        __dirname,
        `../renderer/${CONTROL_WINDOW_VITE_NAME}/index.html`,
      ),
    );
  }

  controlWindow.on("closed", () => {
    app.quit();
  });

  if (debugControl) {
    controlWindow.webContents.openDevTools({
      mode: "detach",
      title: "Control DevTools",
    });
  }
  if (debugPlayer) {
    playerWindow.webContents.openDevTools({
      mode: "detach",
      title: "Player DevTools",
    });
  }

  return { controlWindow, playerWindow };
};

app.whenReady().then(async () => {
  const { controlWindow, playerWindow } = createWindows();

  // Start the web server
  if (enableWebServer) {
    try {
      webServer = new WebServer({ port: SERVER_PORT, host: SERVER_HOST });
      const webServerUrl = await webServer.start();
      console.log(`Web interface available at: ${webServerUrl}`);
    } catch (error) {
      console.error("Failed to start web server:", error);
    }
  }

  setupIpc(controlWindow, playerWindow);
});

app.on("window-all-closed", async () => {
  // Stop the web server when the app is closing
  if (webServer) {
    try {
      await webServer.stop();
    } catch (error) {
      console.error("Error stopping web server:", error);
    }
  }

  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("before-quit", async () => {
  // Ensure web server is stopped before quitting
  if (webServer && webServer.isServerRunning()) {
    try {
      await webServer.stop();
    } catch (error) {
      console.error("Error stopping web server during quit:", error);
    }
  }
});
